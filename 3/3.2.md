# 3.2 切片

**本节内容中包含有一点后续指针中的内容，如果有不理解的，可以在后续看完指针一节后再回头看看**

`切片（Slice）`是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

切片是一个**引用**类型，它的内部结构包含`地址`、`长度`和`容量`。切片一般用于快速地操作一块数据集合。

## 切片的定义

```go
var name []T
```
name:表示变量名

T:表示切片中的元素类型

```go
//example
func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}
```

## 切片的长度及容量

切片拥有自己的长度和容量，我们可以通过使用内置的len()函数求长度，使用内置的cap()函数求切片的容量。

## 切片表达式

切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。

### 简单的切片表达式

```go
a := [5]int{1, 2, 3, 4, 5}
s := a[1:3]  // s := a[low:high]
fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s)) 
//output：  s:[2 3] len(s):2 cap(s):4

s:=a[low:high]
```

上述代码从数组a中选出`1<=索引值<3`的元素组成切片s

可以看到，切片表达式中的`low`和`high`表示一个索引范围，`左闭右开[)`

为了方便起见，可以省略切片表达式中的任何索引。省略了low则默认为0；省略了high则默认为切片操作数的长度:

```go
a[2:]  // 等同于 a[2:len(a)]
a[:3]  // 等同于 a[0:3]
a[:]   // 等同于 a[0:len(a)]
```

**几点需要注意的是：**
1. 对于数组或字符串，如果`0 <= low <= high <= len(a)`，则索引合法，否则就会`索引越界（out of range）`。
2. `切片再切片`，`high`的上限边界是切片的容量`cap(a)`，而**不是**长度。
3. 常量索引必须是非负的，并且可以用`int类型`的值表示;对于数组或常量字符串，常量索引也必须在**有效范围**内。如果`low`和`high`两个指标都是常数，它们必须满足`low <= high`。如果索引在运行时超出范围，就会发生运行时`panic`。

### 完整切片表达式

对于数组，指向数组的指针，或切片a(注意不能是字符串)支持完整切片表达式：
```go
a[low : high : max]
```

上面的代码会构造与简单切片表达式`a[low: high]`相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为`max-low`。在完整切片表达式中**只有**第一个索引值（`low`）可以省略；它默认为0。

完整切片表达式需要满足的条件是`0 <= low <= high <= max <= cap(a)`，其他条件和简单切片表达式相同。

## 使用make()函数构造切片

我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的`make()`函数，格式如下：
```go
make([]T, size, cap)
```
+ T:切片的元素类型
+ size:切片中元素的数量
+ cap:切片的容量

```go
func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
```

## 切片本质
切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。

## 判断切片是否为空

要检查切片是否为空，请始终使用`len(s) == 0`来判断，而**不应该使用**`s == nil`来判断。

切片之间是不能比较的，我们不能使用`==`操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和`nil`比较。 一个`nil`值的切片并**没有底层数组**，一个`nil`值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是`nil`，例如下面的示例：
```go
var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
```
所以要判断一个切片是否是空的，要是用`len(s) == 0`来判断，**不应该使用**`s == nil`来判断。

## 切片赋值拷贝

需要注意的是，两切片变量共享同一底层数组时，对一个切片的修改同时会影响另一个切片内容。

```go
//example
a := [1, 2, 3, 4]
s1 := a[1:3]		//[2 3]
s2 := s1
s2[0] = 114514	
fmt.Println(s1)		//[114514 3]
fmt.Println(s2)		//[114514 3]
```

## 切片遍历

切片遍历方式同数组相同，支持`for range`

```go
func main() {
	s := []int{1, 3, 5}

	for i := 0; i < len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}
}
```

## append()

`append()`可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。

```go
//example
func main(){
	var s []int
	s = append(s, 1)        // [1]
	s = append(s, 2, 3, 4)  // [1 2 3 4]
	s2 := []int{5, 6, 7}  
	s = append(s, s2...)    // [1 2 3 4 5 6 7]
}
```

值得注意的是，
1. 通过var声明的零值切片可以在`append()`函数直接使用，**无需初始化**。
2. “扩容”操作往往发生在`append()`函数调用时，所以我们通常都需要用原变量接收append函数的返回值。每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。

## copy()
上文中，我们说明了，两个切片共享同一底层数组是会相互影响。

由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。

这个时候，`copy()`函数可以迅速地将一个切片的数据复制到另外一个切片空间中，copy()函数的使用格式如下：

```go
copy(destSlice, srcSlice []T)
```

+ srcSlice: 数据来源切片
+ destSlice: 目标切片

## 删除切片元素

Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。
```go
a = append(a[:index], a[index+1:]...)
```

想想上述是如何实现的

## homework
康康下面代码的输出结果。
```go
func main() {
	var a = make([]string, 5, 10)
	for i := 0; i < 10; i++ {
		a = append(a, fmt.Sprintf("%v", i))
	}
	fmt.Println(a)
}
```